{"version":3,"file":"index.js","sources":["../webpack://contribution-automation-action/./src/octokit.js","../webpack://contribution-automation-action/./src/utils/templateParser.js","../webpack://contribution-automation-action/./src/utils/capitalize.js","../webpack://contribution-automation-action/./src/utils/stripDuplicates.js","../webpack://contribution-automation-action/./src/utils/templateBuilder.js","../webpack://contribution-automation-action/./src/core.js","../webpack://contribution-automation-action/./src/query/getSponsersList.gql","../webpack://contribution-automation-action/./src/index.js","../webpack://contribution-automation-action/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://contribution-automation-action/webpack/bootstrap","../webpack://contribution-automation-action/webpack/runtime/make namespace object","../webpack://contribution-automation-action/webpack/runtime/compat","../webpack://contribution-automation-action/webpack/startup"],"sourcesContent":["/**\r\n * Shard octokit client\r\n */\r\nimport * as github from '@actions/github';\r\n\r\n// get repo token\r\nconst token = process.env['GITHUB_TOKEN'];\r\n\r\nconst octokit = github.getOctokit(token);\r\n\r\nexport default octokit;\r\n","/**\r\n * @typedef {Object} parsedData\r\n * @property {string} url - avatar url\r\n * @property {string} name - full name of the github user profile, can be null\r\n */\r\n\r\n/**\r\n * given an input string it will search for all the img tags inside contributors list. readme\r\n * used for using past data for more speed\r\n * parse these \\<img src=github_url alt=github_user_name>github_full_name\\</img>\r\n * into  array of object of three keys each\r\n * @param {string} inputTemplate : multiline string\r\n * @returns {{username:parsedData}[]}\r\n */\r\nconst templateParser = inputTemplate => {\r\n    // regex to parse into an array of three each with url userid and name\r\n    // ntg to match will result in null\r\n    let parsedKeys = inputTemplate.match(/src=\"([\\s\\S]*?)\"|alt=\"([\\s\\S]*?)\"|<b>([\\s\\S]*?)<\\/b>/gm);\r\n    if (!parsedKeys) return {};\r\n\r\n    let data = {};\r\n\r\n    for (let i = 0; i < parsedKeys.length; i = i + 3) {\r\n        let url = parsedKeys[i].substring(5, parsedKeys[i].length - 1);\r\n        let userid = parsedKeys[i + 1].substring(5, parsedKeys[i + 1].length - 1);\r\n        let name = parsedKeys[i + 2].substring(3, parsedKeys[i + 2].length - 4);\r\n        data[userid] = { url, name };\r\n    }\r\n\r\n    return data;\r\n};\r\n\r\nexport default templateParser;\r\n","const capitalCaseUtil = str => {\r\n    return str.charAt(0).toUpperCase() + str.substring(1);\r\n};\r\n\r\nexport default str => {\r\n    return str ? str.split(' ').map(capitalCaseUtil).join(' ') : '';\r\n};\r\n","/**\r\n * function to clean an array of objects with duplicates\r\n * @param {Array} - arr - array of objects\r\n * @param {string} - key - key to compare\r\n */\r\nexport default (arr = [], key) => {\r\n    // if either array or key is null\r\n    if (!arr || !key) return [];\r\n    const unqiue = {};\r\n    const uniqueArray = [];\r\n    for (let index = 0; index < arr.length; index++) {\r\n        const value = arr[index];\r\n        if (!unqiue[value[key]]) {\r\n            unqiue[value[key]] = true;\r\n            uniqueArray.push(value);\r\n        }\r\n    }\r\n    return uniqueArray;\r\n};\r\n","import capitalize from './capitalize';\r\nimport stripDuplicates from './stripDuplicates';\r\nimport octokit from '../octokit';\r\n\r\nimport * as core from '@actions/core';\r\n\r\nexport const getTemplate = (userID, imageSize, name, avatarUrl) => {\r\n    return `\r\n    <td align=\"center\">\r\n        <a href=\"https://github.com/${userID}\">\r\n            <img src=\"${avatarUrl}\" width=\"${imageSize};\" alt=\"${userID}\"/>\r\n            <br />\r\n            <sub><b>${name ? capitalize(name) : userID}</b></sub>\r\n        </a>\r\n    </td>`;\r\n};\r\n\r\n/**\r\n * function to generate userinfo either from prev readme data or using fetch\r\n * @param {string} login : login id of github\r\n * @param {string} avatarUrl : url of the github user\r\n * @param {object} prevContributors : prev contributors list to fetch it like a cache instead of calling\r\n * @param {object} octokit : octokit client\r\n */\r\nexport const getUserInfo = async (login, avatarUrl, prevContributors) => {\r\n    if (prevContributors[login] && prevContributors[login].url) {\r\n        return { name: prevContributors[login].name, url: avatarUrl };\r\n    } else {\r\n        try {\r\n            const user_details = await octokit.users.getByUsername({ username: login });\r\n            return { name: user_details.data.name, url: user_details.data.avatar_url };\r\n        } catch (error) {\r\n            console.log(`Oops...given github id ${login} is invalid :(`);\r\n            return { name: login, url: '' };\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * core function to generate readme template\r\n * @param {object} contributors - contributors object\r\n * @param {object} prevContributors - previous contributors list stored in readme\r\n * @param {string} type - type like bot, contributors, collab\r\n * @param {object} octokit - github octokit client\r\n */\r\nconst templateBuilder = async (contributors, prevContributors, type) => {\r\n    // get various inputs applied in action.yml\r\n    const imageSize = core.getInput('image_size').trim();\r\n    const columns = Number(core.getInput('columns_per_row').trim());\r\n\r\n    let contributors_content = `<!-- readme:${type}-start --> \\n<table>\\n`;\r\n\r\n    contributors = stripDuplicates(contributors, 'login');\r\n\r\n    const rows = Math.ceil(contributors.length / columns);\r\n\r\n    for (let row = 1; row <= rows; row++) {\r\n        contributors_content += '<tr>';\r\n        for (\r\n            let column = 1;\r\n            column <= columns && (row - 1) * columns + column - 1 < contributors.length;\r\n            column++\r\n        ) {\r\n            const { login, avatarUrl, type } = contributors[(row - 1) * columns + column - 1];\r\n\r\n            if (type !== 'bot') {\r\n                const { name, url } = await getUserInfo(login, avatarUrl, prevContributors);\r\n                contributors_content += getTemplate(login, imageSize, name, url);\r\n            } else {\r\n                contributors_content += getTemplate(login, imageSize, login, avatarUrl);\r\n            }\r\n        }\r\n        contributors_content += '</tr>\\n';\r\n    }\r\n\r\n    contributors_content += `</table>\\n<!-- readme:${type}-end -->`;\r\n\r\n    return contributors_content;\r\n};\r\n\r\nexport default templateBuilder;\r\n","import templateParser from './utils/templateParser';\r\nimport templateBuilder from './utils/templateBuilder';\r\n/**\r\n * build a new array by joining given arrays\r\n * @param {Array} values - priority based order\r\n * @param {Array} prevContributors - contributors list of previous readme\r\n * @param {Array} contributors - current contributors\r\n * @param {Array} collaborators - current colloborators\r\n * @param {Array} bots - current bots\r\n * @returns {Array} prdered list\r\n */\r\nconst joinArray = (values, prevContributors, contributors, collaborators, bots) => {\r\n    let joinedArray = [];\r\n\r\n    values.forEach(category => {\r\n        category = category.trim().toLowerCase();\r\n\r\n        switch (category) {\r\n            case 'contributors':\r\n                joinedArray = joinedArray.concat(contributors);\r\n                break;\r\n            case 'collaborators':\r\n                joinedArray = joinedArray.concat(collaborators);\r\n                break;\r\n            case 'bots':\r\n                joinedArray = joinedArray.concat(bots);\r\n                break;\r\n            default:\r\n                prevContributors[category]\r\n                    ? joinedArray.push({\r\n                          login: category,\r\n                          avatarUrl: prevContributors[category].url,\r\n                          name: prevContributors[category].name\r\n                      })\r\n                    : joinedArray.push({ login: category });\r\n                break;\r\n        }\r\n    });\r\n\r\n    return joinedArray;\r\n};\r\n\r\nconst buildContent = async (templateContent, contributors, collaborators, bots, content) => {\r\n    /**\r\n     * regex expression to parse the options passed inside the readme tags\r\n     * eg: <!-- readme:contributors,bots -start --!> anything inside this<!-- readme:contributors,bots -end --!>\r\n     * using the regex we get two groups return as\r\n     *  type: contributors,bots\r\n     *      use: to get the options passed\r\n     *  content: anything that was inside the tag\r\n     *      use: to reuse the html created inside the tah\r\n     */\r\n    // get prev contributors in the readme\r\n    let prevReadmeContributorsTemplate = templateContent.match(\r\n        /<!--\\s*readme:(?<type>[\\s\\S]*?)-start\\s*-->(?<content>[\\s\\S]*?)<!--\\s*readme:[\\s\\S]*?-end\\s*-->/\r\n    );\r\n    const prevContributors = templateParser(prevReadmeContributorsTemplate.groups.content);\r\n    const types = prevReadmeContributorsTemplate.groups.type.split(',');\r\n    const contributorsPool = joinArray(types, prevContributors, contributors, collaborators, bots);\r\n\r\n    let contributors_content = await templateBuilder(\r\n        contributorsPool,\r\n        prevContributors,\r\n        prevReadmeContributorsTemplate.groups.type\r\n    );\r\n\r\n    /**\r\n     * Build back the new template\r\n     * replace it with the old one\r\n     */\r\n    const re = new RegExp(\r\n        `<!--\\\\s*readme:\\\\s*${prevReadmeContributorsTemplate.groups.type}\\\\s*-start\\\\s*-->([\\\\s\\\\S]*?)<!--\\\\s*readme:\\\\s*${prevReadmeContributorsTemplate.groups.type}\\\\s*-end\\\\s*-->`\r\n    );\r\n\r\n    const postprocess_content = content.replace(re, contributors_content);\r\n    return postprocess_content;\r\n};\r\n\r\nexport default buildContent;\r\n","export default `\nquery($owner: String!) {\n    user(login: \"freakboy3742\") {\n        name\n        sponsorshipsAsMaintainer(first: 100) {\n            nodes {\n                sponsorEntity {\n                    ... on User {\n                        name\n                        login\n                        avatarUrl\n                    }\n                }\n            }\n        }\n    }\n}\n`\n","import * as core from '@actions/core';\r\nimport * as github from '@actions/github';\r\nimport octokit from './octokit';\r\n\r\nimport buildContributorsList from './core';\r\nimport getSponserListQuery from './query/getSponsersList.gql';\r\n\r\nasync function run() {\r\n    try {\r\n        if (github.context.payload.action) {\r\n            if (github.context.payload.action !== 'closed') return;\r\n        }\r\n\r\n        // get various inputs applied in action.yml\r\n        const path = core.getInput('readme_path').trim();\r\n        const affiliation = core.getInput('collaborators').trim();\r\n        const message = core.getInput('commit_message').trim();\r\n        const name = core.getInput('committer_username').trim();\r\n        const email = core.getInput('committer_email').trim();\r\n\r\n        // get repo token\r\n        const token = process.env['GITHUB_TOKEN'];\r\n\r\n        if (!token) {\r\n            throw new Error('Token not found');\r\n        }\r\n\r\n        const nwo = process.env['GITHUB_REPOSITORY'] || '/';\r\n        const [owner, repo] = nwo.split('/');\r\n\r\n        // get the readme of the repo\r\n        const readme = await octokit.repos.getContent({ owner, repo, path });\r\n\r\n        if (readme.headers.status === '404') {\r\n            console.log('readme not added');\r\n            return;\r\n        }\r\n\r\n        // get all contributors of the repo max:500\r\n        const contributorsList = await octokit.repos.listContributors({ owner, repo });\r\n        const collaboratorsList = await octokit.repos.listCollaborators({\r\n            owner,\r\n            repo,\r\n            affiliation\r\n        });\r\n        const sponsersList = await octokit.graphql(getSponserListQuery, { owner });\r\n\r\n        // get data of contributors\r\n        // collaborators\r\n        // bots\r\n        const contributors = contributorsList.data.filter(el => el.type !== 'Bot');\r\n        const contributorsBots = contributorsList.data\r\n            .filter(el => el.type === 'Bot')\r\n            .map(({ login, avatar_url }) => ({\r\n                login: login,\r\n                avatarUrl: avatar_url,\r\n                name: login,\r\n                type: 'bot'\r\n            }));\r\n        const collaborators = collaboratorsList.data.filter(el => el.type !== 'Bot');\r\n        const collaboratorsBots = contributorsList.data\r\n            .filter(el => el.type === 'Bot')\r\n            .map(({ login, avatar_url }) => ({\r\n                login: login,\r\n                avatarUrl: avatar_url,\r\n                name: login,\r\n                type: 'bot'\r\n            }));\r\n        const sponsers = sponsersList.user.sponsorshipsAsMaintainer.nodes.map(\r\n            ({ sponsorEntity: { name, login, avatarUrl } }) => ({\r\n                name,\r\n                login,\r\n                avatarUrl\r\n            })\r\n        );\r\n        console.log(sponsers);\r\n        const bots = [...contributorsBots, ...collaboratorsBots];\r\n        // parse the base64 readme\r\n        let content = Buffer.from(readme.data.content, 'base64').toString('ascii');\r\n        const prevContent = content;\r\n\r\n        /**\r\n         * regex expresstion to get all the special readme tags\r\n         * eg: <!-- readme:contributors -start --!> anything inside this<!-- readme:contributors -end --!>\r\n         * gets these matched and the content inside of these tags to an array\r\n         */\r\n        // get all tag comments with the given format\r\n        const getAllReadmeComments = content.match(\r\n            /<!--\\s*readme:\\s*[a-zA-Z0-9,-]*\\s*-start\\s*-->[\\s\\S]*?<!--\\s*readme:\\s*[a-zA-Z0-9,-]*\\s*-end\\s*-->/gm\r\n        );\r\n\r\n        // return action if no tags were found\r\n        if (!getAllReadmeComments) {\r\n            console.log('No contrib comments were attached');\r\n            return;\r\n        }\r\n\r\n        // based on tags update the content\r\n        for (let match = 0; match < getAllReadmeComments.length; match++) {\r\n            content = await buildContributorsList(\r\n                getAllReadmeComments[match],\r\n                contributors,\r\n                collaborators,\r\n                bots,\r\n                content\r\n            );\r\n        }\r\n\r\n        const base64String = Buffer.from(content).toString('base64');\r\n\r\n        if (prevContent !== content) {\r\n            await octokit.repos.createOrUpdateFileContents({\r\n                owner,\r\n                repo,\r\n                message,\r\n                content: base64String,\r\n                path,\r\n                sha: readme.data.sha,\r\n                committer: {\r\n                    name,\r\n                    email\r\n                }\r\n            });\r\n            console.log('Updated contribution section of readme');\r\n        }\r\n    } catch (error) {\r\n        core.setFailed(error.message);\r\n    }\r\n}\r\n\r\nrun();\r\n",null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(564);\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpIA;AACA;AACA;A;;;;;AAFA;AACA;AACA;A;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACNA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}