{"version":3,"file":"index.js","sources":["../webpack://contribution-automation-action/./core.js","../webpack://contribution-automation-action/./index.js","../webpack://contribution-automation-action/./utils/capitalize.js","../webpack://contribution-automation-action/./utils/stripDuplicates.js","../webpack://contribution-automation-action/./utils/templateBuilder.js","../webpack://contribution-automation-action/./utils/templateParser.js","../webpack://contribution-automation-action/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://contribution-automation-action/webpack/bootstrap","../webpack://contribution-automation-action/webpack/runtime/compat","../webpack://contribution-automation-action/webpack/startup"],"sourcesContent":["const templateParser = require('./utils/templateParser');\r\nconst templateBuilder = require('./utils/templateBuilder');\r\n\r\n/**\r\n * build a new array by joining given arrays\r\n * @param {Array} values - priority based order\r\n * @param {Array} prevContributors - contributors list of previous readme\r\n * @param {Array} contributors - current contributors\r\n * @param {Array} collaborators - current colloborators\r\n * @param {Array} bots - current bots\r\n * @returns {Array} prdered list\r\n */\r\nfunction joinArray(values, prevContributors, contributors, collaborators, bots) {\r\n    let joinedArray = [];\r\n\r\n    values.forEach(category => {\r\n        category = category.trim().toLowerCase();\r\n\r\n        switch (category) {\r\n            case 'contributors':\r\n                joinedArray = joinedArray.concat(contributors);\r\n                break;\r\n            case 'collaborators':\r\n                joinedArray = joinedArray.concat(collaborators);\r\n                break;\r\n            case 'bots':\r\n                joinedArray = joinedArray.concat(bots);\r\n                break;\r\n            default:\r\n                prevContributors[category]\r\n                    ? joinedArray.push({\r\n                          login: category,\r\n                          avatar_url: prevContributors[category].url,\r\n                          name: prevContributors[category].name\r\n                      })\r\n                    : joinedArray.push({ login: category });\r\n                break;\r\n        }\r\n    });\r\n\r\n    return joinedArray;\r\n}\r\n\r\nexports.buildContent = async function (\r\n    templateContent,\r\n    contributors,\r\n    collaborators,\r\n    bots,\r\n    content,\r\n    octokit\r\n) {\r\n    /**\r\n     * regex expression to parse the options passed inside the readme tags\r\n     * eg: <!-- readme:contributors,bots -start --!> anything inside this<!-- readme:contributors,bots -end --!>\r\n     * using the regex we get two groups return as\r\n     *  type: contributors,bots\r\n     *      use: to get the options passed\r\n     *  content: anything that was inside the tag\r\n     *      use: to reuse the html created inside the tah\r\n     */\r\n    // get prev contributors in the readme\r\n    let prevReadmeContributorsTemplate = templateContent.match(\r\n        /<!--\\s*readme:(?<type>[\\s\\S]*?)-start\\s*-->(?<content>[\\s\\S]*?)<!--\\s*readme:[\\s\\S]*?-end\\s*-->/\r\n    );\r\n    const prevContributors = templateParser.parser(prevReadmeContributorsTemplate.groups.content);\r\n    const types = prevReadmeContributorsTemplate.groups.type.split(',');\r\n    const contributorsPool = joinArray(types, prevContributors, contributors, collaborators, bots);\r\n\r\n    let contributors_content = await templateBuilder.parser(\r\n        contributorsPool,\r\n        prevContributors,\r\n        prevReadmeContributorsTemplate.groups.type,\r\n        octokit\r\n    );\r\n\r\n    /**\r\n     * Build back the new template\r\n     * replace it with the old one\r\n     */\r\n    const re = new RegExp(\r\n        `<!--\\\\s*readme:\\\\s*${prevReadmeContributorsTemplate.groups.type}\\\\s*-start\\\\s*-->([\\\\s\\\\S]*?)<!--\\\\s*readme:\\\\s*${prevReadmeContributorsTemplate.groups.type}\\\\s*-end\\\\s*-->`\r\n    );\r\n\r\n    const postprocess_content = content.replace(re, contributors_content);\r\n    return postprocess_content;\r\n};\r\n","const core = require('@actions/core');\r\nconst github = require('@actions/github');\r\n\r\nconst readMeCore = require('./core');\r\n\r\nasync function run() {\r\n    try {\r\n        if (github.context.payload.action) {\r\n            if (github.context.payload.action !== 'closed') return;\r\n        }\r\n\r\n        // get various inputs applied in action.yml\r\n        const path = core.getInput('readme_path').trim();\r\n        const affiliation = core.getInput('collaborators').trim();\r\n        const message = core.getInput('commit_message').trim();\r\n        const name = core.getInput('committer_username').trim();\r\n        const email = core.getInput('committer_email').trim();\r\n\r\n        // get repo token\r\n        const token = process.env['GITHUB_TOKEN'];\r\n\r\n        if (!token) {\r\n            throw new Error('Token not found');\r\n        }\r\n\r\n        // octakit library to access various functions\r\n        const octokit = github.getOctokit(token);\r\n        const nwo = process.env['GITHUB_REPOSITORY'] || '/';\r\n        const [owner, repo] = nwo.split('/');\r\n\r\n        // get the readme of the repo\r\n        const readme = await octokit.repos.getContent({ owner, repo, path });\r\n\r\n        if (readme.headers.status === '404') {\r\n            console.log('readme not added');\r\n            return;\r\n        }\r\n\r\n        // get all contributors of the repo max:500\r\n        const contributors_list = await octokit.repos.listContributors({ owner, repo });\r\n        const collaborators_list = await octokit.repos.listCollaborators({\r\n            owner,\r\n            repo,\r\n            affiliation\r\n        });\r\n\r\n        // get data of contributors\r\n        // collaborators\r\n        // bots\r\n        const contributors = contributors_list.data.filter(el => el.type !== 'Bot');\r\n        const contributorsBots = contributors_list.data\r\n            .filter(el => el.type === 'Bot')\r\n            .map(({ login, avatar_url }) => ({\r\n                login: login,\r\n                avatar_url,\r\n                name: login,\r\n                type: 'bot'\r\n            }));\r\n        const collaborators = collaborators_list.data.filter(el => el.type !== 'Bot');\r\n        const collaboratorsBots = contributors_list.data\r\n            .filter(el => el.type === 'Bot')\r\n            .map(({ login, avatar_url }) => ({\r\n                login: login,\r\n                avatar_url,\r\n                name: login,\r\n                type: 'bot'\r\n            }));\r\n        const bots = [...contributorsBots, ...collaboratorsBots];\r\n        // parse the base64 readme\r\n        let content = Buffer.from(readme.data.content, 'base64').toString('ascii');\r\n        const prevContent = content;\r\n\r\n        /**\r\n         * regex expresstion to get all the special readme tags\r\n         * eg: <!-- readme:contributors -start --!> anything inside this<!-- readme:contributors -end --!>\r\n         * gets these matched and the content inside of these tags to an array\r\n         */\r\n        // get all tag comments with the given format\r\n        const getAllReadmeComments = content.match(\r\n            /<!--\\s*readme:\\s*[a-zA-Z0-9,-]*\\s*-start\\s*-->[\\s\\S]*?<!--\\s*readme:\\s*[a-zA-Z0-9,-]*\\s*-end\\s*-->/gm\r\n        );\r\n\r\n        // return action if no tags were found\r\n        if (!getAllReadmeComments) {\r\n            console.log('No contrib comments were attached');\r\n            return;\r\n        }\r\n\r\n        // based on tags update the content\r\n        for (let match = 0; match < getAllReadmeComments.length; match++) {\r\n            content = await readMeCore.buildContent(\r\n                getAllReadmeComments[match],\r\n                contributors,\r\n                collaborators,\r\n                bots,\r\n                content,\r\n                octokit\r\n            );\r\n        }\r\n\r\n        const base64String = Buffer.from(content).toString('base64');\r\n\r\n        if (prevContent !== content) {\r\n            await octokit.repos.createOrUpdateFileContents({\r\n                owner,\r\n                repo,\r\n                message,\r\n                content: base64String,\r\n                path,\r\n                sha: readme.data.sha,\r\n                committer: {\r\n                    name,\r\n                    email\r\n                }\r\n            });\r\n            console.log('Updated contribution section of readme');\r\n        }\r\n    } catch (error) {\r\n        core.setFailed(error.message);\r\n    }\r\n}\r\n\r\nrun();\r\n","function capitalCaseUtil(str) {\r\n    return str.charAt(0).toUpperCase() + str.substring(1);\r\n}\r\n\r\nexports.toCapitalCase = function (str) {\r\n    return str ? str.split(' ').map(capitalCaseUtil).join(' ') : '';\r\n};\r\n","// function to clean an array of objects duplicates\nexports.clean = function (arr, key) {\n    const unqiue = {};\n    const uniqueArray = [];\n    for (let index = 0; index < arr.length; index++) {\n        const value = arr[index];\n        if (!unqiue[value[key]]) {\n            unqiue[value[key]] = true;\n            uniqueArray.push(value);\n        }\n    }\n    return uniqueArray;\n};\n","const capitalize = require('./capitalize');\r\nconst stripDuplicates = require('./stripDuplicates');\r\n\r\nconst core = require('@actions/core');\r\n\r\nfunction getTemplate(userID, imageSize, name, avatar_url) {\r\n    return `\r\n    <td align=\"center\">\r\n        <a href=\"https://github.com/${userID}\">\r\n            <img src=\"${avatar_url}\" width=\"${imageSize};\" alt=\"${userID}\"/>\r\n            <br />\r\n            <sub><b>${name ? capitalize.toCapitalCase(name) : userID}</b></sub>\r\n        </a>\r\n    </td>`;\r\n}\r\n\r\n// to get the full name of a user\r\nasync function getData(login, avatar_url, prevContributors, octokit) {\r\n    if (prevContributors[login] && prevContributors[login].url) {\r\n        return { name: prevContributors[login].name, url: avatar_url };\r\n    } else {\r\n        try {\r\n            const user_details = await octokit.users.getByUsername({ username: login });\r\n            return { name: user_details.data.name, url: user_details.data.avatar_url };\r\n        } catch (error) {\r\n            console.log(`Oops...given github id ${login} is invalid :(`);\r\n            return { name: login, url: '' };\r\n        }\r\n    }\r\n}\r\n\r\n// to build the table layout\r\n// takes prev data to avoid unneccessary call\r\nexports.parser = async function (contributors, prevContributors, type, octokit) {\r\n    // get various inputs applied in action.yml\r\n    const imageSize = core.getInput('image_size').trim();\r\n    const columns = Number(core.getInput('columns_per_row').trim());\r\n\r\n    let contributors_content = `<!-- readme:${type}-start --> \\n<table>\\n`;\r\n\r\n    contributors = stripDuplicates.clean(contributors, 'login');\r\n\r\n    const rows = Math.ceil(contributors.length / columns);\r\n\r\n    for (let row = 1; row <= rows; row++) {\r\n        contributors_content += '<tr>';\r\n        for (\r\n            let column = 1;\r\n            column <= columns && (row - 1) * columns + column - 1 < contributors.length;\r\n            column++\r\n        ) {\r\n            const { login, avatar_url, type } = contributors[(row - 1) * columns + column - 1];\r\n\r\n            if (type !== 'bot') {\r\n                const { name, url } = await getData(login, avatar_url, prevContributors, octokit);\r\n                contributors_content += getTemplate(login, imageSize, name, url);\r\n            } else {\r\n                contributors_content += getTemplate(login, imageSize, login, avatar_url);\r\n            }\r\n        }\r\n        contributors_content += '</tr>\\n';\r\n    }\r\n\r\n    contributors_content += `</table>\\n<!-- readme:${type}-end -->`;\r\n\r\n    return contributors_content;\r\n};\r\n","// to convert given html template to an object\n// to reuse the old data for efficiency\n\nexports.parser = function (str) {\n    // regex to parse into an array of three each with url userid and name\n    // ntg to match will result in null\n    let parsedKeys = str.match(/src=\"([\\s\\S]*?)\"|alt=\"([\\s\\S]*?)\"|<b>([\\s\\S]*?)<\\/b>/gm);\n    if (!parsedKeys) return {};\n\n    let data = {};\n\n    for (let i = 0; i < parsedKeys.length; i = i + 3) {\n        let url = parsedKeys[i].substring(5, parsedKeys[i].length - 1);\n        let userid = parsedKeys[i + 1].substring(5, parsedKeys[i + 1].length - 1);\n        let name = parsedKeys[i + 2].substring(3, parsedKeys[i + 2].length - 4);\n        data[userid] = { url, name };\n    }\n\n    return data;\n};\n",null,"// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\n__webpack_require__.ab = __dirname + \"/\";","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(932);\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;ACrBA;AACA;AACA;A;;;;;AAFA;AACA;AACA;A;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5BA;AACA;ACDA;AACA;AACA;AACA;;A","sourceRoot":""}